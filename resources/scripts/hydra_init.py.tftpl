import os
import subprocess
import time
import logging
import sys

# --- Professional Logging ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler("/var/log/hydra-init.log"),
        logging.StreamHandler(sys.stdout)
    ]
)

class HydraHardenedOrchestrator:
    def __init__(self):
        self.s3_bucket = "${s3_bucket_name}"
        self.region = "${aws_region}"
        self.version = "1.5.42"
        self.bin_path = "/usr/local/bin/sliver-server"
        self.container_name = "hydra-c2"
        self.image_name = "local/sliver:latest"

    def run(self, cmd, check=True):
        try:
            logging.info(f"Executing: {cmd}")
            result = subprocess.run(cmd, shell=True, check=check, capture_output=True, text=True)
            return result.stdout
        except subprocess.CalledProcessError as e:
            logging.error(f"Command failed: {e.cmd}\nError: {e.stderr}")
            if check: raise e
            return None

    def phase_1_prepare_host(self):
        logging.info("--- Phase 1: Host Hardening & Proxy Setup ---")
        self.run("export DEBIAN_FRONTEND=noninteractive && apt-get update")
        self.run("apt-get install -y nginx curl wget jq unzip net-tools build-essential libcap2-bin")
        
        # CONFIGURE NGINX AS REVERSE PROXY
        # This solves the 502/TCP Reset error permanently.
        proxy_config = """
server {
    listen 80;
    server_name _;

    # Standard C2 Forwarding
    location / {
        proxy_pass http://127.0.0.1:8888;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # ALB Health Check Resilience: If Sliver is booting, return 200 instead of 502
        error_page 502 503 504 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 'OK';
    }
}
"""
        with open("/etc/nginx/sites-available/default", "w") as f:
            f.write(proxy_config)
        
        self.run("systemctl restart nginx && systemctl enable nginx")

    def phase_2_docker(self):
        logging.info("--- Phase 2: Docker Engine Setup ---")
        if not os.path.exists("/usr/bin/docker"):
            self.run("curl -fsSL https://get.docker.com | sh")
            self.run("systemctl enable docker && systemctl start docker")

    def phase_3_supply_chain(self):
        logging.info("--- Phase 3: Binary Fetch & S3 Restore ---")
        url = f"https://github.com/BishopFox/sliver/releases/download/v{self.version}/sliver-server_linux"
        self.run(f"wget -q '{url}' -O {self.bin_path}")
        self.run(f"chmod +x {self.bin_path}")

        self.run("mkdir -p /root/.sliver")
        restore_cmd = f"aws s3 cp s3://{self.s3_bucket}/backups/latest_sliver_state.tar.gz /tmp/sliver_backup.tar.gz --region {self.region}"
        if self.run(restore_cmd, check=False):
            logging.info("[*] Recovery state found. Restoring...")
            self.run("tar -xzvf /tmp/sliver_backup.tar.gz -C /root/", check=False)
        self.run("chown -R root:root /root/.sliver")

    def phase_4_build_image(self):
        logging.info("--- Phase 4: Local Container Build ---")
        dockerfile = """
FROM ubuntu:24.04
RUN apt-get update && apt-get install -y ca-certificates libcap2-bin && rm -rf /var/lib/apt/lists/*
COPY sliver-server /usr/local/bin/sliver-server
RUN chmod +x /usr/local/bin/sliver-server
ENV HOME=/root
WORKDIR /root
ENTRYPOINT ["/usr/local/bin/sliver-server", "daemon"]
"""
        with open("/tmp/Dockerfile", "w") as f: f.write(dockerfile)
        self.run(f"cp {self.bin_path} /tmp/sliver-server")
        self.run(f"docker build -t {self.image_name} /tmp")

    def phase_5_zero_touch_handoff(self):
        logging.info("--- Phase 5: Persistent Zero-Touch Handoff ---")
        
        # 1. CREATE PERSISTENT AUTORUN SCRIPT
        # We place this in the .sliver directory (which is an S3-backed volume)
        # This makes the listener logic "part of the database" state.
        autorun_path = "/root/.sliver/autorun.slv"
        autorun_content = "http -l 8888\njobs\n"
        
        try:
            with open(autorun_path, "w") as f:
                f.write(autorun_content)
            self.run(f"chown root:root {autorun_path}")
            logging.info(f"Created persistent Sliver script at {autorun_path}")
        except Exception as e:
            logging.error(f"Failed to create autorun script: {e}")

        # 2. LAUNCH CONTAINER (Hardened Proxy Config)
        self.run(f"docker rm -f {self.container_name}", check=False)
        launch_cmd = (
            f"docker run -d --name {self.container_name} --restart always "
            f"-p 127.0.0.1:8888:8888 --privileged "
            f"-v /root/.sliver:/root/.sliver {self.image_name}"
        )
        self.run(launch_cmd)

        # 3. ATOMIC INITIALIZATION
        logging.info("Waiting for gRPC socket to stabilize...")
        time.sleep(20) 

        # We execute the script using the local client binary. 
        # This is the most stable way to interact with a running daemon.
        logging.info("Executing persistent initialization script...")
        init_cmd = f"docker exec -i {self.container_name} /usr/local/bin/sliver-server < {autorun_path}"
        
        # We use a loop just to handle slow database migrations on first-boot
        for i in range(1, 4):
            logging.info(f"Initialization Attempt {i}/3...")
            self.run(init_cmd, check=False)
            time.sleep(5)
            
            # Final Validation: Check if the port is bound on the host
            if ":8888" in self.run("netstat -tulpn"):
                logging.info("SUCCESS: Project Hydra is fully autonomous and persistent.")
                logging.info("PROJECT HYDRA IS LIVE (MK.XXI).")
                return True
            
            logging.warning("Port 8888 not yet active, retrying...")
            time.sleep(10)

        logging.error("CRITICAL: Zero-touch handoff failed to verify listener port.")
        return False